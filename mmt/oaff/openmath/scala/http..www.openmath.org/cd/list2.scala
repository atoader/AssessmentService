//Source file generated by the Universal OpenMath Machine

package org.openmath.www.cd
import info.kwarc.mmt.api._
import objects._
import uom._
import ConstantScala._

trait list2 extends TheoryScala {
  def list2_list_selector(x1: Term, x2: Term): Term

  def list2_first(x1: Term): Term

  def list2_rest(x1: Term): Term

  def list2_append(x1: Term, x2: Term): Term

  def list2_cons(x1: Term, x2: Term): Term

  def list2_nil(): Term

  def list2_reverse(x1: Term): Term

  def list2_size(x1: Term): Term

  def list2_in(x1: Term, x2: Term): Term

}

object list2 extends TheoryScalaAux {
  val _base = DPath(utils.URI("http", "www.openmath.org") / "cd")
  val _path = _base ? "list2"

  object list_selector extends ConstantScala {
    val parent = _path
    val name = "list_selector"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object first extends ConstantScala {
    val parent = _path
    val name = "first"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object rest extends ConstantScala {
    val parent = _path
    val name = "rest"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object append extends ConstantScala {
    val parent = _path
    val name = "append"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object cons extends ConstantScala {
    val parent = _path
    val name = "cons"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object nil extends ConstantScala {
    val parent = _path
    val name = "nil"
  // no apply method generated for this arity
  // no unapply methods generated for this arity
  }


  object reverse extends ConstantScala {
    val parent = _path
    val name = "reverse"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object size extends ConstantScala {
    val parent = _path
    val name = "size"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object in extends ConstantScala {
    val parent = _path
    val name = "in"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


}

