//Source file generated by the Universal OpenMath Machine

package org.openmath.www.cd
import info.kwarc.mmt.api._
import objects._
import uom._
import ConstantScala._

trait set1 extends TheoryScala {
  def set1_cartesian_product(xs1: List[Term]): Term

  def set1_emptyset(): Term

  def set1_map(x1: Term, x2: Term): Term

  def set1_size(x1: Term): Term

  def set1_suchthat(x1: Term, x2: Term): Term

  def set1_set(xs1: List[Term]): Term

  def set1_intersect(xs1: List[Term]): Term

  def set1_union(xs1: List[Term]): Term

  def set1_setdiff(x1: Term, x2: Term): Term

  def set1_in(x1: Term, x2: Term): Term

  def set1_notin(x1: Term, x2: Term): Term

  def set1_subset(x1: Term, x2: Term): Term

  def set1_prsubset(x1: Term, x2: Term): Term

  def set1_notsubset(x1: Term, x2: Term): Term

  def set1_notprsubset(x1: Term, x2: Term): Term

}

object set1 extends TheoryScalaAux {
  val _base = DPath(utils.URI("http", "www.openmath.org") / "cd")
  val _path = _base ? "set1"

  object cartesian_product extends ConstantScala {
    val parent = _path
    val name = "cartesian_product"
    def apply(xs1: List[Term]) = OMA(OMID(this.path), xs1)
    def unapply(t: Term): Option[List[Term]] = t match {
      case OMA(OMID(this.path), xs1) => Some(xs1)
      case _ => None
    }
  }


  object emptyset extends ConstantScala {
    val parent = _path
    val name = "emptyset"
  // no apply method generated for this arity
  // no unapply methods generated for this arity
  }


  object map extends ConstantScala {
    val parent = _path
    val name = "map"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object size extends ConstantScala {
    val parent = _path
    val name = "size"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object suchthat extends ConstantScala {
    val parent = _path
    val name = "suchthat"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object set extends ConstantScala {
    val parent = _path
    val name = "set"
    def apply(xs1: List[Term]) = OMA(OMID(this.path), xs1)
    def unapply(t: Term): Option[List[Term]] = t match {
      case OMA(OMID(this.path), xs1) => Some(xs1)
      case _ => None
    }
  }


  object intersect extends ConstantScala {
    val parent = _path
    val name = "intersect"
    def apply(xs1: List[Term]) = OMA(OMID(this.path), xs1)
    def unapply(t: Term): Option[List[Term]] = t match {
      case OMA(OMID(this.path), xs1) => Some(xs1)
      case _ => None
    }
  }


  object union extends ConstantScala {
    val parent = _path
    val name = "union"
    def apply(xs1: List[Term]) = OMA(OMID(this.path), xs1)
    def unapply(t: Term): Option[List[Term]] = t match {
      case OMA(OMID(this.path), xs1) => Some(xs1)
      case _ => None
    }
  }


  object setdiff extends ConstantScala {
    val parent = _path
    val name = "setdiff"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object in extends ConstantScala {
    val parent = _path
    val name = "in"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object notin extends ConstantScala {
    val parent = _path
    val name = "notin"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object subset extends ConstantScala {
    val parent = _path
    val name = "subset"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object prsubset extends ConstantScala {
    val parent = _path
    val name = "prsubset"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object notsubset extends ConstantScala {
    val parent = _path
    val name = "notsubset"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object notprsubset extends ConstantScala {
    val parent = _path
    val name = "notprsubset"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


}

