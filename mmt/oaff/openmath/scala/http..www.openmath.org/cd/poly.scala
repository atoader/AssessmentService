//Source file generated by the Universal OpenMath Machine

package org.openmath.www.cd
import info.kwarc.mmt.api._
import objects._
import uom._
import ConstantScala._

trait poly extends TheoryScala {
  def poly_power(x1: Term, x2: Term): Term

  def poly_factored(xs1: List[Term]): Term

  def poly_squarefreed(xs1: List[Term]): Term

  def poly_partially_factored(xs1: List[Term]): Term

  def poly_expand(x1: Term): Term

  def poly_degree(x1: Term): Term

  def poly_degree_wrt(x1: Term, x2: Term): Term

  def poly_leading_coefficient(x1: Term, x2: Term): Term

  def poly_coefficient(x1: Term, x2: Term, x3: Term): Term

  def poly_coefficient_ring(x1: Term): Term

  def poly_evaluate(x1: Term, xs2: List[Term]): Term

  def poly_factor(x1: Term): Term

  def poly_squarefree(x1: Term): Term

  def poly_discriminant(x1: Term, x2: Term): Term

  def poly_resultant(x1: Term, x2: Term, x3: Term): Term

  def poly_convert(x1: Term, x2: Term): Term

}

object poly extends TheoryScalaAux {
  val _base = DPath(utils.URI("http", "www.openmath.org") / "cd")
  val _path = _base ? "poly"

  object power extends ConstantScala {
    val parent = _path
    val name = "power"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object factored extends ConstantScala {
    val parent = _path
    val name = "factored"
    def apply(xs1: List[Term]) = OMA(OMID(this.path), xs1)
    def unapply(t: Term): Option[List[Term]] = t match {
      case OMA(OMID(this.path), xs1) => Some(xs1)
      case _ => None
    }
  }


  object squarefreed extends ConstantScala {
    val parent = _path
    val name = "squarefreed"
    def apply(xs1: List[Term]) = OMA(OMID(this.path), xs1)
    def unapply(t: Term): Option[List[Term]] = t match {
      case OMA(OMID(this.path), xs1) => Some(xs1)
      case _ => None
    }
  }


  object partially_factored extends ConstantScala {
    val parent = _path
    val name = "partially_factored"
    def apply(xs1: List[Term]) = OMA(OMID(this.path), xs1)
    def unapply(t: Term): Option[List[Term]] = t match {
      case OMA(OMID(this.path), xs1) => Some(xs1)
      case _ => None
    }
  }


  object expand extends ConstantScala {
    val parent = _path
    val name = "expand"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object degree extends ConstantScala {
    val parent = _path
    val name = "degree"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object degree_wrt extends ConstantScala {
    val parent = _path
    val name = "degree_wrt"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object leading_coefficient extends ConstantScala {
    val parent = _path
    val name = "leading_coefficient"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object coefficient extends ConstantScala {
    val parent = _path
    val name = "coefficient"
    def apply(x1: Term, x2: Term, x3: Term) = OMA(OMID(this.path), x1 :: x2 :: x3:: Nil)
    def unapply(t: Term): Option[(Term, Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2 :: x3:: Nil) => Some((x1, x2, x3))
      case _ => None
    }
  }


  object coefficient_ring extends ConstantScala {
    val parent = _path
    val name = "coefficient_ring"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object evaluate extends ConstantScala {
    val parent = _path
    val name = "evaluate"
    def apply(x1: Term, xs2: List[Term]) = OMA(OMID(this.path), x1 :: xs2)
    def unapply(t: Term): Option[(Term, List[Term])] = t match {
      case OMA(OMID(this.path), x1 :: xs2) => Some((x1, xs2))
      case _ => None
    }
  }


  object factor extends ConstantScala {
    val parent = _path
    val name = "factor"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object squarefree extends ConstantScala {
    val parent = _path
    val name = "squarefree"
    def apply(x1: Term) = OMA(OMID(this.path), x1:: Nil)
    def unapply(t: Term): Option[Term] = t match {
      case OMA(OMID(this.path), x1:: Nil) => Some(x1)
      case _ => None
    }
  }


  object discriminant extends ConstantScala {
    val parent = _path
    val name = "discriminant"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object resultant extends ConstantScala {
    val parent = _path
    val name = "resultant"
    def apply(x1: Term, x2: Term, x3: Term) = OMA(OMID(this.path), x1 :: x2 :: x3:: Nil)
    def unapply(t: Term): Option[(Term, Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2 :: x3:: Nil) => Some((x1, x2, x3))
      case _ => None
    }
  }


  object convert extends ConstantScala {
    val parent = _path
    val name = "convert"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


}

