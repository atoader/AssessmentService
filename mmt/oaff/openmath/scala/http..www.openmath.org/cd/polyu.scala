//Source file generated by the Universal OpenMath Machine

package org.openmath.www.cd
import info.kwarc.mmt.api._
import objects._
import uom._
import ConstantScala._

trait polyu extends TheoryScala {
  def polyu_term(x1: Term, x2: Term): Term

  def polyu_poly_u_rep(x1: Term, xs2: List[Term]): Term

  def polyu_polynomial_u(x1: Term, x2: Term): Term

  def polyu_polynomial_ring_u(x1: Term, x2: Term): Term

}

object polyu extends TheoryScalaAux {
  val _base = DPath(utils.URI("http", "www.openmath.org") / "cd")
  val _path = _base ? "polyu"

  object term extends ConstantScala {
    val parent = _path
    val name = "term"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object poly_u_rep extends ConstantScala {
    val parent = _path
    val name = "poly_u_rep"
    def apply(x1: Term, xs2: List[Term]) = OMA(OMID(this.path), x1 :: xs2)
    def unapply(t: Term): Option[(Term, List[Term])] = t match {
      case OMA(OMID(this.path), x1 :: xs2) => Some((x1, xs2))
      case _ => None
    }
  }


  object polynomial_u extends ConstantScala {
    val parent = _path
    val name = "polynomial_u"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object polynomial_ring_u extends ConstantScala {
    val parent = _path
    val name = "polynomial_ring_u"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


}

