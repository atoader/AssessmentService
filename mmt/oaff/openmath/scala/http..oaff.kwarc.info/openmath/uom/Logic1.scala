//Source file generated by the Universal OpenMath Machine

package info.kwarc.oaff.openmath.uom
import info.kwarc.mmt.api._
import objects._
import uom._
import ConstantScala._

import org.openmath.www.cd._

import logic1._

trait Logic1 extends ViewScala with logic1 {
  // UOM start http://oaff.kwarc.info/openmath/uom?Logic1?false
  def logic1_false() : Term = {
    OMS(logic1.`false`.path)
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Logic1?false

  // UOM start http://oaff.kwarc.info/openmath/uom?Logic1?true
  def logic1_true() : Term = {
    OMS(logic1.`true`.path)
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Logic1?true

  // UOM start http://oaff.kwarc.info/openmath/uom?Logic1?equivalent
  def logic1_equivalent(a: Term, b: Term) : Term = {
    (a,b) match {
    	case (`false`.term, `false`.term) => `true`
    	case (`false`.term, `true`.term) => `false`
    	case (`true`.term, `false`.term) => `false`
      case (`true`.term, `true`.term) => `true`
      case _ => equivalent(a,b)  
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Logic1?equivalent

  // UOM start http://oaff.kwarc.info/openmath/uom?Logic1?implies
  def logic1_implies(a: Term, b: Term) : Term = {
    (a,b) match {
    	case (`false`.term, _) => `true`
    	case (`true`.term, `false`.term) => `false`
      case (_, `true`.term) => `true`
      case _ => implies(a,b)  
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Logic1?implies

  // UOM start http://oaff.kwarc.info/openmath/uom?Logic1?not
  def logic1_not(a: Term) : Term = {
    a match {
      case `true`.term => `false`
      case `false`.term => `true`
      case _ => not(a)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Logic1?not

  // UOM start http://oaff.kwarc.info/openmath/uom?Logic1?and
  def logic1_and(args: List[Term]) : Term = {
    var restArgs: List[Term] = Nil
      var foundFalse = false
      
      args.foreach {
      	case `true`.term =>
        case `false`.term => foundFalse = true
        case a => restArgs ::= a
      }
      if (foundFalse) {
        `false`
      } else {
        restArgs match {
          case Nil => `true`
          case _ => and(restArgs)
        }
      }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Logic1?and

  // UOM start http://oaff.kwarc.info/openmath/uom?Logic1?or
  def logic1_or(args: List[Term]) : Term = {
    var restArgs: List[Term] = Nil
      var foundTrue = false
      
      args.foreach {
      	case `false`.term =>
        case `true`.term => foundTrue = true
        case a => restArgs ::= a
      }
      if (foundTrue) {
        `true`
      } else {
        restArgs match {
          case Nil => `false`
          case _ => or(restArgs)
        }
      }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Logic1?or

  // UOM start http://oaff.kwarc.info/openmath/uom?Logic1?xor
  def logic1_xor(args: List[Term]) : Term = {
    var restArgs: List[Term] = Nil
      var countTrue = 0
      
      args.foreach {
      	case `false`.term =>
        case `true`.term => countTrue += 1
        case a => restArgs ::= a
      }
      restArgs match {
        case Nil => if (countTrue % 2 == 1) `true` else `false`
        case _ => if (countTrue % 2 == 1) xor(`true` :: restArgs) else xor(restArgs)
      }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Logic1?xor

  declares(Implementation.constant(logic1.`false`.path)(logic1_false _))
  declares(Implementation.constant(logic1.`true`.path)(logic1_true _))
  declares(Implementation.AA(logic1.equivalent.path)(logic1_equivalent _))
  declares(Implementation.AA(logic1.implies.path)(logic1_implies _))
  declares(Implementation.A(logic1.not.path)(logic1_not _))
  declares(Implementation.S(logic1.and.path)(logic1_and _))
  declares(Implementation.S(logic1.or.path)(logic1_or _))
  declares(Implementation.S(logic1.xor.path)(logic1_xor _))

}

object Logic1 extends Logic1

