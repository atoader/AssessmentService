//Source file generated by the Universal OpenMath Machine

package info.kwarc.oaff.openmath.uom
import info.kwarc.mmt.api._
import objects._
import uom._
import ConstantScala._

import org.openmath.www.cd._

import relation1._

trait Relation1 extends ViewScala with relation1 {
  // UOM start http://oaff.kwarc.info/openmath/uom?Relation1?eq
  def relation1_eq(a: Term, b: Term) : Term = {
    (a,b) match {
      case (OMI(x1), OMI(x2)) => Utils.ombool(x1 == x2)
      case (OMI(x1), OMF(x2)) => Utils.ombool(x1.toDouble == x2)
      case (OMI(x), nums1.rational(OMI(n), OMI(d))) => Utils.ombool(x * d == n)
      case (OMI(_), complex1.complex_cartesian(re, im)) => Numbers.eqRC(a, b, re, im)
      case (OMF(x1), OMI(x2)) => Utils.ombool(x1 == x2.toDouble)
      case (OMF(x1), OMF(x2)) => Utils.ombool(x1 == x2)
      case (OMF(x), nums1.rational(OMI(n), OMI(d))) => Utils.ombool(x * d.toDouble == n.toDouble)
      case (OMF(_), complex1.complex_cartesian(re, im)) => Numbers.eqRC(a, b, re, im)
      case (nums1.rational(OMI(n), OMI(d)), OMI(x)) => Utils.ombool(x * d == n)
      case (nums1.rational(OMI(n), OMI(d)), OMF(x)) => Utils.ombool(x * d.toDouble == n.toDouble)
      case (nums1.rational(OMI(n1), OMI(d1)), nums1.rational(OMI(n2), OMI(d2))) =>
        Utils.ombool(n1 * d2 == n2 * d1)
      case (nums1.rational(_), complex1.complex_cartesian(re, im)) => Numbers.eqRC(a, b, re, im)
      case (complex1.complex_cartesian(_), OMI(_)) => OMeq(b,a)
      case (complex1.complex_cartesian(_), OMF(_)) => OMeq(b,a)
      case (complex1.complex_cartesian(_), nums1.rational(_)) => OMeq(b,a)
      case (complex1.complex_cartesian(r1, i1), complex1.complex_cartesian(r2, i2)) =>
      	logic1.and(OMeq(r1, r2), OMeq(i1, i2))
      case (set1.set(ls1), set1.set(ls2)) =>
        if (Utils.isFullyKnown(a) && Utils.isFullyKnown(b)) {
          Utils.ombool(ls1.toSet == ls2.toSet)
        } else {
          OMeq(a, b)
        }
      case _ => if (a == b) logic1.`true` else OMeq(a,b)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Relation1?eq

  // UOM start http://oaff.kwarc.info/openmath/uom?Relation1?lt
  def relation1_lt(a: Term, b: Term) : Term = {
    Numbers.lessThan(a,b) match {
      case Some(tf) => Utils.ombool(tf)
      case None => lt(a,b)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Relation1?lt

  // UOM start http://oaff.kwarc.info/openmath/uom?Relation1?gt
  def relation1_gt(a: Term, b: Term) : Term = {
    lt(b,a)
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Relation1?gt

  // UOM start http://oaff.kwarc.info/openmath/uom?Relation1?neq
  def relation1_neq(a: Term, b: Term) : Term = {
    logic1.not(OMeq(a,b))
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Relation1?neq

  // UOM start http://oaff.kwarc.info/openmath/uom?Relation1?leq
  def relation1_leq(a: Term, b: Term) : Term = {
    logic1.or(lt(a,b), OMeq(a,b))
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Relation1?leq

  // UOM start http://oaff.kwarc.info/openmath/uom?Relation1?geq
  def relation1_geq(a: Term, b: Term) : Term = {
    logic1.or(gt(a,b), OMeq(a,b))
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Relation1?geq

  // UOM start http://oaff.kwarc.info/openmath/uom?Relation1?approx
  def relation1_approx(x1: Term, x2: Term) : Term = {
    throw Unimplemented("relation1_approx")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Relation1?approx

  declares(Implementation.AA(relation1.OMeq.path)(relation1_eq _))
  declares(Implementation.AA(relation1.lt.path)(relation1_lt _))
  declares(Implementation.AA(relation1.gt.path)(relation1_gt _))
  declares(Implementation.AA(relation1.neq.path)(relation1_neq _))
  declares(Implementation.AA(relation1.leq.path)(relation1_leq _))
  declares(Implementation.AA(relation1.geq.path)(relation1_geq _))
  declares(Implementation.AA(relation1.approx.path)(relation1_approx _))

}

object Relation1 extends Relation1

