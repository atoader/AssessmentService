//Source file generated by the Universal OpenMath Machine

package info.kwarc.oaff.openmath.uom
import info.kwarc.mmt.api._
import objects._
import uom._
import ConstantScala._

import org.openmath.www.cd._

import arith1._

trait LinalgArith extends ViewScala with arith1 {
  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?plus
  def arith1_plus(args: List[Term]) : Term = {
    var matrices: List[List[Term]] = Nil
      var restArgs: List[Term] = Nil
      args.foreach {
        case v@linalg2.vector(_) => matrices ::= List(v)
        case linalg2.matrix(m) => matrices ::= m
        case a => restArgs ::= a 
      }
      
      matrices.length match {
        case 0 => plus(restArgs)
        case 1 => Utils.plusWithRest(linalg2.matrix(matrices(0)), restArgs)
        case _ => 
          val rCounts = matrices.map(_.length)
          val cCounts = matrices.map(m => Linalgs.vectorSize(m(0)))
          if (rCounts.forall(_ == rCounts(0)) && cCounts.forall(_ == cCounts(0))) {
            if (rCounts(0) == 1) { // only vectors
              val vsum = Linalgs.addVectors(matrices)
              Utils.plusWithRest(vsum, restArgs)
            } else {
              Utils.plusWithRest(linalg2.matrix(List.transpose(matrices).map(plus(_))), restArgs)
            }
          } else {
            throw UOMException("matrices cannot be added")
          }
      }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?plus

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?minus
  def arith1_minus(x1: Term, x2: Term) : Term = {
    throw Unimplemented("arith1_minus")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?minus

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?times
  def arith1_times(args: List[Term]) : Term = {
    for (i <- Range(0, args.length - 1)) {
      val a = args(i)
      val b = args(i + 1)
      if (Linalgs.isVecOrMat(args(i)) && Linalgs.isVecOrMat(args(i + 1))) {
        val a = Linalgs.toMatrix(args(i))
        val b = Linalgs.toMatrix(args(i + 1))
        if (Linalgs.dimMatchMult(a, b)) {
          val prod = Linalgs.binaryMatMult(a, b)
          if (args.length == 2)
            return prod
          else
            return arith1.times(args.take(i) ::: List(prod) ::: args.takeRight(args.length - i - 2))
        } else {
          throw UOMException(s"matrix multiplication(${a}, ${b}: dimensions do not match")
        }
      }
    }
    return arith1.times(args)
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?times

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?divide
  def arith1_divide(x1: Term, x2: Term) : Term = {
    throw Unimplemented("arith1_divide")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?divide

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?power
  def arith1_power(x1: Term, x2: Term) : Term = {
    throw Unimplemented("arith1_power")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?power

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?root
  def arith1_root(x1: Term, x2: Term) : Term = {
    throw Unimplemented("arith1_root")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?root

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?abs
  def arith1_abs(x1: Term) : Term = {
    throw Unimplemented("arith1_abs")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?abs

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?unary_minus
  def arith1_unary_minus(x1: Term) : Term = {
    throw Unimplemented("arith1_unary_minus")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?unary_minus

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?gcd
  def arith1_gcd(xs1: List[Term]) : Term = {
    throw Unimplemented("arith1_gcd")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?gcd

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?lcm
  def arith1_lcm(xs1: List[Term]) : Term = {
    throw Unimplemented("arith1_lcm")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?lcm

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?product
  def arith1_product(x1: Term, x2: Term) : Term = {
    throw Unimplemented("arith1_product")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?product

  // UOM start http://oaff.kwarc.info/openmath/uom?LinalgArith?sum
  def arith1_sum(x1: Term, x2: Term) : Term = {
    throw Unimplemented("arith1_sum")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?LinalgArith?sum

  declares(Implementation.S(arith1.plus.path)(arith1_plus _))
  declares(Implementation.AA(arith1.minus.path)(arith1_minus _))
  declares(Implementation.S(arith1.times.path)(arith1_times _))
  declares(Implementation.AA(arith1.divide.path)(arith1_divide _))
  declares(Implementation.AA(arith1.power.path)(arith1_power _))
  declares(Implementation.AA(arith1.root.path)(arith1_root _))
  declares(Implementation.A(arith1.abs.path)(arith1_abs _))
  declares(Implementation.A(arith1.unary_minus.path)(arith1_unary_minus _))
  declares(Implementation.S(arith1.gcd.path)(arith1_gcd _))
  declares(Implementation.S(arith1.lcm.path)(arith1_lcm _))
  declares(Implementation.AA(arith1.product.path)(arith1_product _))
  declares(Implementation.AA(arith1.sum.path)(arith1_sum _))

}

object LinalgArith extends LinalgArith

