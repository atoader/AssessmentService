//Source file generated by the Universal OpenMath Machine

package info.kwarc.oaff.openmath.uom
import info.kwarc.mmt.api._
import objects._
import uom._
import ConstantScala._

import org.openmath.www.cd._

import arith1._

trait Arith1 extends ViewScala with arith1 {
  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?plus
  def arith1_plus(args: List[Term]) : Term = {
    var floatSum: Double = 0
    var rationalSum = Rational(0, 1)
    var realTerms: List[Term] = Nil
    var imaginaryTerms: List[Term] = Nil
    var partialResult: Term = OMI(0)
    var restArgs: List[Term] = Nil
       	
    args.foreach {
      case OMI(i) => floatSum += i.toDouble
      case OMF(f) => floatSum += f
      case nums1.rational(OMI(a), OMI(b)) => rationalSum += Rational(a, b)
      case cc@complex1.complex_cartesian(re, im) =>
        if (Utils.isFullyKnown(cc)) {
          realTerms ::= re
          imaginaryTerms ::= im
        } else {
          restArgs ::= cc	
        }
      case cp@complex1.complex_polar(r, phi) =>
        if (Utils.isFullyKnown(cp)) {
          realTerms ::= times(r, transc1.cos(phi))
          imaginaryTerms ::= times(r, transc1.sin(phi))
        } else {
          restArgs ::= cp
        }
      case a => restArgs ::= a
    }
      
    var fqSum = (floatSum, rationalSum.toDouble) match {
      case (0, 0) => List(OMI(0))
      case (0, _) => List(rationalSum.toTerm)
      case (_, 0) => List(Numbers.double2Term(floatSum))
      case _ =>
        if (rationalSum.isInt)
          List(Numbers.double2Term(floatSum + rationalSum.toDouble))
        else {
          var s = floatSum + rationalSum.toDouble
          if (Numbers.isInt(s)) 
            List(OMI(s.toInt))
          else
            List(Numbers.double2Term(floatSum), rationalSum.toTerm)
        } 
    }
      
    if (imaginaryTerms.length == 0)
      partialResult = if (fqSum.length == 1) fqSum(0) else plus(fqSum(0), fqSum(1))
    else
      partialResult = complex1.complex_cartesian(plus(fqSum ::: realTerms.reverse), plus(imaginaryTerms.reverse))
        
    restArgs = restArgs.reverse
    (restArgs, partialResult) match {
      case (Nil, _) =>  partialResult
      case (_, OMI(i)) => if (i == 0) plus(restArgs) else plus(partialResult :: restArgs)
      case (_, OMF(0)) => plus(restArgs)
      case _ => plus(partialResult :: restArgs)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?plus

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?minus
  def arith1_minus(a: Term, b: Term) : Term = {
    plus(a, unary_minus(b))
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?minus

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?times
  def arith1_times(args: List[Term]) : Term = {
    var floatProd: Double = 1
    var rationalProd: Rational = Rational(1, 1)
    var radii: List[Term] = Nil
    var angles: List[Term] = Nil
    var partialResult: Term = OMI(0)
    var restArgs : List[Term] = Nil

    args foreach {
      case OMI(i) => floatProd *= i.toDouble
      case OMF(f) => floatProd *= f
      case nums1.rational(OMI(a), OMI(b)) => rationalProd *= Rational(a, b)
      case cc@complex1.complex_cartesian(re, im) =>
        if (Utils.isFullyKnown(cc)) {
          radii ::= root(plus(times(re, re), times(im, im)), OMI(2))
          angles ::= complex1.argument(cc)
        } else {
          restArgs ::= cc	
        }
      case cp@complex1.complex_polar(r, phi) =>
        if (Utils.isFullyKnown(cp)) {
          radii ::= r
          angles ::= phi
        } else {
          restArgs ::= cp
        }
      case a => restArgs ::= a
    }
    
    if (floatProd == 0 || rationalProd.toDouble == 0) {
      OMI(0)
    } else {
      var fqProd = (floatProd, rationalProd.toDouble) match {
        case (0, _) | (_, 0) => List(OMI(0))
        case (1, _) => List(rationalProd.toTerm)
        case (_, 1) => List(Numbers.double2Term(floatProd))
        case _ =>
          var fq = floatProd * rationalProd.toDouble
          if (rationalProd.isInt)
            List(Numbers.double2Term(fq))
          else
            if (Numbers.isInt(fq)) List(Numbers.double2Term(fq)) else List(Numbers.double2Term(floatProd), rationalProd.toTerm)
      }
      if (angles.length == 0) {
        partialResult = if (fqProd.length == 1) fqProd(0) else times(fqProd(0), fqProd(1))
      } else {
        partialResult = complex1.complex_polar(times(fqProd ::: radii.reverse), plus(angles.reverse))
      }
      restArgs = restArgs.reverse
      (restArgs, partialResult) match {
        case (Nil, _) =>  partialResult
        case (_, OMI(i)) => if (i == 1) times(restArgs) else times(partialResult :: restArgs)
        case (_, OMF(1)) => times(restArgs)
        case _ => times(partialResult :: restArgs)
      }
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?times

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?divide
  def arith1_divide(a: Term, b: Term) : Term = {
    times(a, power(b, OMI(-1)))
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?divide

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?power
  def arith1_power(a: Term, b: Term) : Term = {
    a match {
      case OMI(i) => Numbers.raise(i.toDouble, b)
      case OMF(f) => Numbers.raise(f, b)
      case nums1.rational(p, q) => nums1.rational(power(p, b), power(q, b))
      case complex1.complex_cartesian(re, im) => power(Numbers.cartesianToPolar(re, im), b)
      case complex1.complex_polar(r, phi) => complex1.complex_polar(power(r, b), times(phi, b))
      case _ => power(a, b)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?power

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?root
  def arith1_root(a: Term, b: Term) : Term = {
    power(a, power(b, OMI(-1)))
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?root

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?abs
  def arith1_abs(a: Term) : Term = {
    a match {
      case OMI(i) => OMI(math.abs(i.toInt))
      case OMF(f) => OMF(math.abs(f))
      case nums1.rational(a, b) => nums1.rational(abs(a), abs(b))
      case complex1.complex_cartesian(a, b) => root(plus(times(a,a), times(b,b)), OMI(2))
      case complex1.complex_polar(r, phi) => r
      case _ => abs(a)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?abs

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?unary_minus
  def arith1_unary_minus(a: Term) : Term = {
    a match {
      case OMI(i) => OMI(-i)
      case OMF(f) => OMF(-f)
      case nums1.rational(a, b) => nums1.rational(unary_minus(a), b)
      case complex1.complex_cartesian(a, b) => complex1.complex_cartesian(unary_minus(a), unary_minus(b))
      case complex1.complex_polar(r, phi) => complex1.complex_polar(unary_minus(r), phi)
      case linalg2.vector(ls) => linalg2.vector(ls.map(unary_minus(_)))
      case linalg2.matrix(ls) => linalg2.matrix(ls.map(unary_minus(_)))
      case polyu.term(exp, coeff) => polyu.term(exp, unary_minus(coeff))
      case polyu.poly_u_rep(x, ls) => polyu.poly_u_rep(x, ls.map(unary_minus(_)))
      case polyu.polynomial_u(p, r) => polyu.polynomial_u(unary_minus(p), r)
      case _ => unary_minus(a)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?unary_minus

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?gcd
  def arith1_gcd(args: List[Term]) : Term = {
    var gcdAll: BigInt = 0
    var restArgs: List[Term] = Nil
      
    args.foreach {
      case OMI(n) => gcdAll = gcdAll.gcd(n)
      case a => restArgs ::= a
    }
    restArgs match {
      case Nil => OMI(gcdAll)
      case _ => gcd(OMI(gcdAll) :: restArgs.reverse)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?gcd

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?lcm
  def arith1_lcm(args: List[Term]) : Term = {
    def lcm2(a: BigInt, b: BigInt): BigInt = {
      return math.abs(a.toInt * b.toInt) / a.gcd(b)
    }
    var lcmAll: BigInt = 1
    var restArgs: List[Term] = Nil
      
    args.foreach {
      case OMI(n) => lcmAll = lcm2(lcmAll, n)
      case a => restArgs ::= a
    }
    restArgs match {
      case Nil => OMI(lcmAll)
      case _ => lcm(OMI(lcmAll) :: restArgs.reverse)
    }
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?lcm

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?product
  def arith1_product(x1: Term, x2: Term) : Term = {
    throw Unimplemented("arith1_product")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?product

  // UOM start http://oaff.kwarc.info/openmath/uom?Arith1?sum
  def arith1_sum(x1: Term, x2: Term) : Term = {
    throw Unimplemented("arith1_sum")
  }
  // UOM end http://oaff.kwarc.info/openmath/uom?Arith1?sum

  declares(Implementation.S(arith1.plus.path)(arith1_plus _))
  declares(Implementation.AA(arith1.minus.path)(arith1_minus _))
  declares(Implementation.S(arith1.times.path)(arith1_times _))
  declares(Implementation.AA(arith1.divide.path)(arith1_divide _))
  declares(Implementation.AA(arith1.power.path)(arith1_power _))
  declares(Implementation.AA(arith1.root.path)(arith1_root _))
  declares(Implementation.A(arith1.abs.path)(arith1_abs _))
  declares(Implementation.A(arith1.unary_minus.path)(arith1_unary_minus _))
  declares(Implementation.S(arith1.gcd.path)(arith1_gcd _))
  declares(Implementation.S(arith1.lcm.path)(arith1_lcm _))
  declares(Implementation.AA(arith1.product.path)(arith1_product _))
  declares(Implementation.AA(arith1.sum.path)(arith1_sum _))

}

object Arith1 extends Arith1

