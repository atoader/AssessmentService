This directory contains the MMT archive for the OpenMath CDs and the implementations for the UOM.

1. DIRECTORY STRUCTURE

The source folder contains the original development.
  source:      the MMT meta-theories for OpenMath and Scala and the bifoundations between them
  source/cds:  the MMT theories representing the OpenMath CDs
  source/uom:  realizations (views) from the OpenMath CDs to Scala that are used by the universal machine
  source/test: extensions of the OpenMath CDs with examples and the corresponding extensions of the realizations

The folders compiled, content, narration, notation, relational contain the OMDoc files produced by MMT when building the archive as well as MMT's indices for the archive.

The folder scala contains the generated Scala source code.
The scala files are arranged by namespace in accordance with Java conventions.
  http..www.openmath.org/cd:      the namespace of the OpenMath CDs, one scala trait file per CD
  http..oaff.kwarc.info/openmath: the namespace of our developments
     uom:                         the realizations mentioned above, one scala object per view
     test:                        the test cases and the views realizing them

Additionally, one file NAMESPACE.scala is generated per directory.
These contain code to iterate over all CDs and all realizations in that folder.
In particular, this permits registering all realizations with the universal machine and running all test cases.

Any editor or IDE can be used to change the scala folder.
For example, the root folder is at the time an eclipse Scala project that can be imported into an eclipse workspace.

The bin folder contains the class files generated by compiling the scala folder.
The utils folder contains helper objects and methods useful for the implementations.


2. BUILDING THE ARCHIVE

It is not necessary to build the archive manually because the most important results of the build are also checked into the repository: the folders scala and content and the openmath.jar file.

To build manually, use the MMT script build.msl, which will build the archive and produce the folders compiled, content, narration, notation, relational, scala as well as openmath.mar (the MMT archive) and openmath.jar (a Java archive containing the realizations).

This script can be run by

  1) checking out MMT via SVN from https://svn.kwarc.info/repos/MMT/deploy

  2) running
   
     PATH/TO/deploy/run-file.sh PATH/TO/build.msl (build.msl in this directory)

     (or using run-file.bat on Windows).

If there are errors on the first build, you may have to repeat step 2 multiple times.



3. HOW TO USE IT WITH THE UNIVERSAL MACHINE

This is how you can run the UOM interactively by

  1) checking out MMT via SVN from https://svn.kwarc.info/repos/MMT/deploy (if you haven't done that already)

  2) running
   
     PATH/TO/deploy/run-file.sh PATH/TO/interactive.msl  (interactive.msl in this directory)

     (or using run-file.bat on Windows).
  
This will first run the test cases from source/test and outputs the result for each one.
Each test case is given together with the theory and name under which it is declared in source/test.
A test consists of an OpenMath expression, and it is passed if the expression is simplified to logic1.true.

If you do not want to run the MMT script, you can also just look at test.log in this directory: It contains the output of running interactive.msl.

After the tests finish, the script starts the interactive scala interpreter. (This may require Java 1.7.)
Wait a few seconds until the `scala-mmt>` prompt appears.

To test the UOM yourself, enter
  
  uom"EXPRESSION_TO_BE_EVALUATED".

This will run Scala's string interpolation together with the MMT parser and the UOM. The result will appear below.
For example, if you want to add two vectors, you can either write
  
  scala-mmt> uom"vector 1 2 3 + vector 2 3 4" // 'vector' implements the OpenMath linalg2?vector.
  
  or

  scala-mmt> uom"⟨1,2,3⟩ + ⟨2,3,4⟩" // this uses the MMT notation for vectors
  
In both cases, the result will be
  
  info.kwarc.mmt.api.objects.Term = (linalg2?vector 3 5 7)

Notice that if you want to construct an OpenMath term, like vector, matrix, list, set, append, and, floor etc, 
you can either use the name of the symbol as in the OpenMath CD, or the MMT notation (we provide notations for most of the 
OpenMath concepts). You can find the notation of a symbol by looking at the file in which it is declared (these are all in 
source/cds). For example, the append symbol is defined in the source/cds/list.mmt, because append is part of the
list CD group. It's defined as
  append # 1 ::: 2
  
append is the same name as in the OpenMath CD, and 1 ::: 2 says that it takes two arguments, separated by :::.
    
So, you can write
   uom"append (list 2 3) (list 3 4 5)"    or    uom"[2,3] ::: [3,4,5]"   or   uom"append [2,3] [3,4,5]"

Note that for some symbols, e.g. vectors or matrices, the notations (and therefore also the examples below) contain Unicode symbols. GNU unifont is a good font for displaying them properly.

Here are some more examples:

  scala-mmt> uom"3+4*5-2"
  res15: info.kwarc.mmt.api.objects.Term = 21
  
  scala-mmt> uom"CC 2 3 + CC 5 5" // addition of complex_cartesians (CC is the notation for complex_cartesian)
  res16: info.kwarc.mmt.api.objects.Term = (complex1?complex_cartesian 7 8)
  
  scala-mmt> uom"⟨1,2,3⟩ ⋅ ⟨2,3,4⟩"  // dot product between vectors
  res18: info.kwarc.mmt.api.objects.Term = 20
  
  scala-mmt> uom"⟪⟨1,2⟩, ⟨2,3⟩⟫ + ⟪⟨4,5⟩, ⟨6,7⟩⟫" // matrix addition
  res19: info.kwarc.mmt.api.objects.Term = (linalg2?matrix (linalg2?vector 5 7) (linalg2?vector 8 10))
  
  scala-mmt> uom"[2,3] ::: [4,5,6]" // append two lists
  res20: info.kwarc.mmt.api.objects.Term = (list1?list 2 3 4 5 6)
  
  scala-mmt> uom"false ∧ true ∧ true ∧ false"
  res21: info.kwarc.mmt.api.objects.Term = logic1?false
  
  scala-mmt> uom"min [5,2,1,4]"
  res22: info.kwarc.mmt.api.objects.Term = 1
  
  scala-mmt> uom"trunc 3.4"
  res23: info.kwarc.mmt.api.objects.Term = 3
  
  scala-mmt> uom"⌈ 3.4 ⌉" // ceiling
  res24: info.kwarc.mmt.api.objects.Term = 4
  
  scala-mmt> uom"card {1,2,3,4}" // cardinal of a set
  res26: info.kwarc.mmt.api.objects.Term = 4
  
  scala-mmt> uom"prod {2,3}, {4,5}" // cartesian product
  res28: info.kwarc.mmt.api.objects.Term = (set1?set (tensor1?tuple 4 3) (tensor1?tuple 5 2) (tensor1?tuple 4 2) (tensor1?  tuple 5 3))
  
  scala-mmt> uom"{1,2,3} ∖ {1,2,4}" // set difference
  res31: info.kwarc.mmt.api.objects.Term = (set1?set 3)
  
  scala-mmt> uom"{1,2,3} ⋃ {2,3,4} ⋃ {4,5,6}" // set union
  res17: info.kwarc.mmt.api.objects.Term = (set1?set 6 5 4 2 1 3)
  
  scala-mmt> uom"{3,1,2} ⊆ {1,2,7,3,5}" // subset
  res32: info.kwarc.mmt.api.objects.Term = logic1?true
  
  scala-mmt> uom"{1,2} ⊄ {2,3,1}" // not proper subset
  res33: info.kwarc.mmt.api.objects.Term = logic1?false
  
  scala-mmt> uom"cos 3"
  res34: info.kwarc.mmt.api.objects.Term = -0.9899924966004454


You can also reuse previous results using the $ notation from Scala's string interpolation, e.g.,

  scala-mmt> uom"3+4"
  res1: info.kwarc.mmt.api.objects.Term = 7
  
  scala-mmt> uom"5*$res1"
  res2: info.kwarc.mmt.api.objects.Term = 35
  
We can also escape back and forth between MMT and Scala, e.g., we can run OpenMath computations for all elements in a Scala List

  scala-mmt> List(1,2,3,4,5).map(x => uom"$x ^ 2")
  res3: List[info.kwarc.mmt.api.objects.Term] = List(1, 4, 9, 16, 25)

  scala-mmt> List(1,2,3,4,5).map(x => uom"3*$x - $x ^ 2 < 0")
  res4: List[info.kwarc.mmt.api.objects.Term] = List(logic1?false, logic1?false, logic1?false, logic1?true, logic1?true)


